class PerformanceOptimizer{constructor(){this.cache = new Map();this.memoCache = new Map();this.debounceTimers = new Map();this.throttleTimers = new Map()}debounce(func, delay = 300, key = 'default'){return (...args) =>{if (this.debounceTimers.has(key)){clearTimeout(this.debounceTimers.get(key))}const timer = setTimeout(() =>{func.apply(this, args);this.debounceTimers.delete(key)}, delay);this.debounceTimers.set(key, timer)}}throttle(func, limit = 300, key = 'default'){return (...args) =>{if (!this.throttleTimers.has(key)){func.apply(this, args);this.throttleTimers.set(key, true);setTimeout(() =>{this.throttleTimers.delete(key)}, limit)}}}memoize(func, keyGenerator = (...args) => JSON.stringify(args)){return (...args) =>{const key = keyGenerator(...args);if (this.memoCache.has(key)){return this.memoCache.get(key)}const result = func.apply(this, args);this.memoCache.set(key, result);return result}}batchDOMUpdate(container, items, renderFunc){const fragment = document.createDocumentFragment();items.forEach((item) =>{const element = renderFunc(item);if (element){fragment.appendChild(element)}});container.innerHTML = '';container.appendChild(fragment)}virtualScroll(container, items, renderFunc, itemHeight = 100, visibleCount = 10){let scrollTop = 0;const updateView = () =>{const startIndex = Math.floor(scrollTop / itemHeight);const endIndex = Math.min(startIndex + visibleCount, items.length);const visibleItems = items.slice(startIndex, endIndex);container.style.height = `${items.length * itemHeight}px`;container.style.position = 'relative';const fragment = document.createDocumentFragment();visibleItems.forEach((item, index) =>{const element = renderFunc(item);if (element){element.style.position = 'absolute';element.style.top = `${(startIndex + index) * itemHeight}px`;fragment.appendChild(element)}});container.innerHTML = '';container.appendChild(fragment)};container.addEventListener( 'scroll', this.throttle( () =>{scrollTop = container.scrollTop;updateView()}, 100, 'virtualScroll' ) );updateView()}optimizedFilter(array, condition){const result = [];const length = array.length;for (let arrayIndex = 0;arrayIndex < length;arrayIndex++){if (condition(array[arrayIndex], arrayIndex, array)){result.push(array[arrayIndex])}}return result}removeDuplicates(array, keyFunc = (item) => item){const seen = new Set();const result = [];for (const item of array){const key = keyFunc(item);if (!seen.has(key)){seen.add(key);result.push(item)}}return result}findWithEarlyReturn(array, condition){for (const item of array){if (condition(item)){return item}}return null}chunk(array, size = 100){const chunks = [];for (let arrayIndex = 0;arrayIndex < array.length;arrayIndex += size){chunks.push(array.slice(i, i + size))}return chunks}async processBatch(items, processor, batchSize = 100){try{const results = [];const chunks = this.chunk(items, batchSize);for (const chunk of chunks){const chunkResults = await Promise.all(chunk.map((item) => processor(item)));results.push(...chunkResults);await new Promise((resolve) => setTimeout(resolve, 0))}return results}catch (error){console.error('❌ 배치 처리 실패:', error);throw new Error(`배치 처리에 실패했습니다: ${error.message}`)}}setCache(key, value, ttl = 60000){const expiry = Date.now() + ttl;this.cache.set(key,{value, expiry})}getCache(key){const cached = this.cache.get(key);if (!cached){return null}if (Date.now() > cached.expiry){this.cache.delete(key);return null}return cached.value}clearCache(key){if (key){this.cache.delete(key)}else{this.cache.clear()}}clearMemoCache(key){if (key){this.memoCache.delete(key)}else{this.memoCache.clear()}}rafUpdate(callback){requestAnimationFrame(() =>{callback()})}idleCallback(callback, options ={}){if ('requestIdleCallback' in window){requestIdleCallback(callback, options)}else{setTimeout(callback, 1)}}lazyLoadImages(container){const images = container.querySelectorAll('img[data-src]');const imageObserver = new IntersectionObserver((entries, observer) =>{entries.forEach((entry) =>{if (entry.isIntersecting){const img = entry.target;img.src = img.dataset.src;img.removeAttribute('data-src');observer.unobserve(img)}})});images.forEach((img) => imageObserver.observe(img))}cleanup(){this.debounceTimers.forEach((timer) => clearTimeout(timer));this.debounceTimers.clear();this.throttleTimers.clear();this.cache.clear();this.memoCache.clear()}}const performanceOptimizer = new PerformanceOptimizer();export default performanceOptimizer;if (typeof module !== 'undefined' && module.exports){module.exports = performanceOptimizer}