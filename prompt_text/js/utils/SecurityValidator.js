class SecurityValidator{constructor(){this.rules ={maxLength:{title: 100, description: 500, content: 10000, feedback: 1000, notes: 500, email: 254, url: 2048}, patterns:{email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/, url: (() =>{const urlPattern = '^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}' + '\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?& return new RegExp(urlPattern)})(), alphanumeric: /^[a-zA-Z0-9]+$/, noSpecialChars: /^[a-zA-Z0-9\s\-_.,!?]+$/}, xssPatterns: [ /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, /<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, /javascript:/gi, /on\w+\s*=/gi, /<embed\b/gi, /<object\b/gi ]};this.rateLimitStore = new Map()}validate(value, options ={}){const errors = [];if (options.required && (value === null || value === undefined || value === '')){errors.push('필수 항목입니다');return{valid: false, errors}}if (!value){return{valid: true, errors: []}}if (options.type){const typeError = this.validateType(value, options.type);if (typeError) errors.push(typeError)}if (options.maxLength){const lengthError = this.validateLength(value, options.maxLength);if (lengthError) errors.push(lengthError)}if (options.minLength){if (value.length < options.minLength){errors.push(`최소 ${options.minLength}자 이상 입력해주세요`)}}if (options.format){const formatError = this.validateFormat(value, options.format);if (formatError) errors.push(formatError)}if (options.xss !== false){const xssError = this.validateXSS(value);if (xssError) errors.push(xssError)}if (options.custom){const customError = options.custom(value);if (customError) errors.push(customError)}return{valid: errors.length === 0, errors}}validateType(value, type){switch (type){case 'string': if (typeof value !== 'string'){return '문자열이어야 합니다'}break;case 'number': if (typeof value !== 'number' || isNaN(value)){return '숫자여야 합니다'}break;case 'boolean': if (typeof value !== 'boolean'){return 'true 또는 false여야 합니다'}break;case 'array': if (!Array.isArray(value)){return '배열이어야 합니다'}break;case 'object': if (typeof value !== 'object' || value === null || Array.isArray(value)){return '객체여야 합니다'}break}return null}validateLength(value, maxLength){if (value.length > maxLength){return `최대 ${maxLength}자까지 입력 가능합니다 (현재: ${value.length}자)`}return null}validateFormat(value, format){const pattern = this.rules.patterns[format];if (!pattern){return null}if (!pattern.test(value)){switch (format){case 'email': return '유효한 이메일 주소를 입력해주세요';case 'url': return '유효한 URL을 입력해주세요 (http: case 'alphanumeric': return '영문자와 숫자만 입력 가능합니다';case 'noSpecialChars': return '특수 문자는 .-_.,!?만 사용 가능합니다';default: return '형식이 올바르지 않습니다'}}return null}validateXSS(value){for (const pattern of this.rules.xssPatterns){if (pattern.test(value)){return '허용되지 않는 문자가 포함되어 있습니다'}}return null}escapeHtml(text){if (!text) return '';const map ={'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '/': '&#x2F;'};return text.replace(/[&<>"'/]/g, (char) => map[char])}unescapeHtml(text){if (!text) return '';const map ={'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"', '&#x27;': "'", '&#x2F;': '/'};return text.replace(/&amp;|&lt;|&gt;|&quot;|&#x27;|&#x2F;/g, (entity) => map[entity])}filterSpecialChars(text, allowed = 'a-zA-Z0-9\\s\\-_.,!?'){const regex = new RegExp(`[^${allowed}]`, 'g');return text.replace(regex, '')}checkRateLimit(key, limit = 10, window = 60000){const now = Date.now();if (!this.rateLimitStore.has(key)){this.rateLimitStore.set(key,{count: 1, resetTime: now + window});return{allowed: true, remaining: limit - 1}}const record = this.rateLimitStore.get(key);if (now > record.resetTime){this.rateLimitStore.set(key,{count: 1, resetTime: now + window});return{allowed: true, remaining: limit - 1}}if (record.count >= limit){const retryAfter = Math.ceil((record.resetTime - now) / 1000);return{allowed: false, remaining: 0, retryAfter}}record.count++;return{allowed: true, remaining: limit - record.count}}maskSensitiveData(text, type = 'email'){if (!text) return '';switch (type){case 'email': return text.replace(/^(.{1})(.*)(@.*)$/, (match, first, middle, domain) =>{return first + '*'.repeat(middle.length) + domain});case 'phone': return text.replace(/(\d{3})-(\d{4})-(\d{4})/, '$1-****-$3');case 'card': return text.replace(/(\d{4})-(\d{4})-(\d{4})-(\d{4})/, '****-****-****-$4');default: if (text.length <= 4){return '*'.repeat(text.length)}return text.substring(0, 2) + '*'.repeat(text.length - 4) + text.substring(text.length - 2)}}sanitizeForLog(data){const sensitiveKeys = ['password', 'token', 'apiKey', 'secret', 'creditCard', 'ssn'];const sanitize = (obj) =>{if (typeof obj !== 'object' || obj === null){return obj}if (Array.isArray(obj)){return obj.map((item) => sanitize(item))}const sanitized ={};for (const [key, value] of Object.entries(obj)){if (sensitiveKeys.some((sensitive) => key.toLowerCase().includes(sensitive))){sanitized[key] = '[REDACTED]'}else if (typeof value === 'object'){sanitized[key] = sanitize(value)}else{sanitized[key] = value}}return sanitized};return sanitize(data)}safeJsonParse(json){try{return JSON.parse(json)}catch (error){console.error('JSON 파싱 실패:', error);return null}}generateCsrfToken(){const array = new Uint8Array(32);crypto.getRandomValues(array);return Array.from(array, (byte) => byte.toString(16).padStart(2, '0')).join('')}verifyCsrfToken(token, storedToken){return token === storedToken}cleanup(){this.rateLimitStore.clear()}}const securityValidator = new SecurityValidator();export default securityValidator;if (typeof module !== 'undefined' && module.exports){module.exports = securityValidator}