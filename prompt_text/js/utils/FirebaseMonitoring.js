import{auth, db}from '../../firebase-config.js';import{collection, query, where, getDocs, onSnapshot, orderBy, limit}from 'firebase/firestore';import errorHandler from './ErrorHandler.js';class FirebaseMonitoring{constructor(){this.listeners = [];this.metrics ={auth:{}, firestore:{}, functions:{}, performance:{}};this.alertInterval = null;this.init()}async init(){try{await this.setupAuthMonitoring();await this.setupFirestoreMonitoring();await this.setupPerformanceMonitoring()}catch (error){const errorInfo = errorHandler.handle(error,{component: 'FirebaseMonitoring', method: 'init'});errorHandler.showToUser(errorInfo);errorHandler.trackError(errorInfo)}}async setupAuthMonitoring(){try{const unsubscribe = auth.onAuthStateChanged((user) =>{if (user){try{this.metrics.auth ={userId: user.uid || '', email: user.email || '', emailVerified: user.emailVerified || false, createdAt: user.metadata?.creationTime || null, lastSignIn: user.metadata?.lastSignInTime || null, provider: (user.providerData && user.providerData.length > 0) ? user.providerData[0]?.providerId : null}}catch (error){console.error('âŒ ì‚¬ìš©ìž ì¸ì¦ ìƒíƒœ ì²˜ë¦¬ ì‹¤íŒ¨:', error);this.metrics.auth ={}}}else{this.metrics.auth ={}}});this.listeners.push(unsubscribe)}catch (error){const errorInfo = errorHandler.handle(error,{component: 'FirebaseMonitoring', method: 'setupAuthMonitoring'});errorHandler.showToUser(errorInfo);errorHandler.trackError(errorInfo)}}async setupFirestoreMonitoring(){try{const promptsRef = collection(db, 'prompts');const promptsSnapshot = await getDocs(promptsRef);const executionsRef = collection(db, 'executions');const executionsSnapshot = await getDocs(executionsRef);const ratingsRef = collection(db, 'ratings');const ratingsSnapshot = await getDocs(ratingsRef);this.metrics.firestore ={prompts:{count: promptsSnapshot.size, lastUpdated: new Date().toISOString()}, executions:{count: executionsSnapshot.size, lastUpdated: new Date().toISOString()}, ratings:{count: ratingsSnapshot.size, lastUpdated: new Date().toISOString()}};this.setupRealtimeMonitoring()}catch (error){const errorInfo = errorHandler.handle(error.code || 'firestore/unavailable',{component: 'FirebaseMonitoring', method: 'setupFirestoreMonitoring'});errorHandler.showToUser(errorInfo);errorHandler.trackError(errorInfo)}}setupRealtimeMonitoring(){const recentPromptsQuery = query(collection(db, 'prompts'), orderBy('createdAt', 'desc'), limit(10));const unsubscribePrompts = onSnapshot(recentPromptsQuery, (snapshot) =>{const changes = snapshot.docChanges();changes.forEach((change) =>{if (change.type === 'added'){)}if (change.type === 'modified'){)}if (change.type === 'removed'){}})});this.listeners.push(unsubscribePrompts);const recentExecutionsQuery = query(collection(db, 'executions'), orderBy('executedAt', 'desc'), limit(10));const unsubscribeExecutions = onSnapshot(recentExecutionsQuery, (snapshot) =>{const changes = snapshot.docChanges();changes.forEach((change) =>{if (change.type === 'added'){)}})});this.listeners.push(unsubscribeExecutions)}async setupPerformanceMonitoring(){try{if (window.performance && window.performance.timing){const timing = window.performance.timing;const loadTime = timing.loadEventEnd - timing.navigationStart;const domReadyTime = timing.domContentLoadedEventEnd - timing.navigationStart;const renderTime = timing.domComplete - timing.domLoading;this.metrics.performance ={pageLoad: loadTime, domReady: domReadyTime, render: renderTime, timestamp: new Date().toISOString()}}this.monitorFirebaseOperations()}catch (error){const errorInfo = errorHandler.handle(error,{component: 'FirebaseMonitoring', method: 'setupPerformanceMonitoring'});errorHandler.showToUser(errorInfo);errorHandler.trackError(errorInfo)}}monitorFirebaseOperations(){const originalGetDocs = getDocs;window.monitoredGetDocs = async (...args) =>{const startTime = performance.now();try{const result = await originalGetDocs(...args);const endTime = performance.now();const duration = endTime - startTime}ms`);return result}catch (error){console.error('âŒ Firestore ì½ê¸° ì˜¤ë¥˜:', error);throw error}}}async collectErrorLogs(){try{const errorsRef = collection(db, 'errors');const recentErrorsQuery = query(errorsRef, orderBy('timestamp', 'desc'), limit(50));const snapshot = await getDocs(recentErrorsQuery);const errors = [];snapshot.forEach((doc) =>{errors.push({id: doc.id, ...doc.data()})});return errors}catch (error){const errorInfo = errorHandler.handle(error.code || 'firestore/unavailable',{component: 'FirebaseMonitoring', method: 'collectErrorLogs'});errorHandler.trackError(errorInfo);return []}}async getUserActivityStats(){try{const now = new Date();const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);const executionsQuery = query( collection(db, 'executions'), where('executedAt', '>=', oneDayAgo.toISOString()) );const executionsSnapshot = await getDocs(executionsQuery);const ratingsQuery = query(collection(db, 'ratings'), where('createdAt', '>=', oneDayAgo.toISOString()));const ratingsSnapshot = await getDocs(ratingsQuery);const stats ={last24Hours:{executions: executionsSnapshot.size, ratings: ratingsSnapshot.size, timestamp: now.toISOString()}};return stats}catch (error){const errorInfo = errorHandler.handle(error.code || 'firestore/unavailable',{component: 'FirebaseMonitoring', method: 'getUserActivityStats'});errorHandler.trackError(errorInfo);return null}}setupAlerts(){if (this.alertInterval){clearInterval(this.alertInterval)}const ERROR_THRESHOLD = 10;const PERFORMANCE_THRESHOLD = 3000;this.alertInterval = setInterval( async () =>{const errors = await this.collectErrorLogs();const recentErrors = errors.filter((error) =>{const errorTime = new Date(error.timestamp);const now = new Date();const diffMinutes = (now - errorTime) / (1000 * 60);return diffMinutes <= 5});if (recentErrors.length >= ERROR_THRESHOLD){this.sendAlert('error', `ìµœê·¼ 5ë¶„ê°„ ${recentErrors.length}ê°œì˜ ì—ëŸ¬ ë°œìƒ`)}}, 5 * 60 * 1000 );if (this.metrics.performance.pageLoad > PERFORMANCE_THRESHOLD){this.sendAlert('performance', `íŽ˜ì´ì§€ ë¡œë“œ ì‹œê°„ì´ ${this.metrics.performance.pageLoad}msë¡œ ëŠë¦½ë‹ˆë‹¤`)}}cleanup(){if (this.alertInterval){clearInterval(this.alertInterval);this.alertInterval = null}this.listeners.forEach((unsubscribe) =>{if (typeof unsubscribe === 'function'){unsubscribe()}});this.listeners = []}sendAlert(type, message){console.warn(`ðŸš¨ [${type.toUpperCase()}] ${message}`)}async getDashboardData(){try{const [errors, activityStats] = await Promise.all([this.collectErrorLogs(), this.getUserActivityStats()]);return{auth: this.metrics.auth, firestore: this.metrics.firestore, performance: this.metrics.performance, errors: errors.slice(0, 10), activity: activityStats}}catch (error){const errorInfo = errorHandler.handle(error,{component: 'FirebaseMonitoring', method: 'getDashboardData'});errorHandler.showToUser(errorInfo);errorHandler.trackError(errorInfo);return null}}exportMetrics(){const metricsData ={timestamp: new Date().toISOString(), metrics: this.metrics};const blob = new Blob([JSON.stringify(metricsData, null, 2)],{type: 'application/json'});const url = URL.createObjectURL(blob);const downloadLink = document.createElement('a');downloadLink.href = url;downloadLink.download = `firebase-metrics-${Date.now()}.json`;downloadLink.click();URL.revokeObjectURL(url)}cleanup(){this.listeners.forEach((unsubscribe) => unsubscribe());this.listeners = []}}export default FirebaseMonitoring;