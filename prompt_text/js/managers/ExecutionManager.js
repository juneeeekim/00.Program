class ExecutionManager{constructor(db, auth, templateEngine){if (!db || !auth){throw new Error('ExecutionManager: db와 auth는 필수 파라미터입니다.')}this.db = db;this.auth = auth;this.templateEngine = templateEngine;this.currentUser = null;this.cache = new Map();this.cacheTimeout = 5 * 60 * 1000;this.pendingRequests = new Map()}_isNetworkError(error){const networkErrorCodes = ['unavailable', 'deadline-exceeded', 'resource-exhausted', 'cancelled'];return ( networkErrorCodes.includes(error.code) || error.message.includes('network') || error.message.includes('offline') )}_handleFirestoreQueryError(error, operation = '쿼리 실행'){if (error.code === 'permission-denied' || error.code === 'firestore/permission-denied'){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('firestore/permission-denied',{component: 'ExecutionManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('접근 권한이 없습니다. 로그인 상태를 확인하거나 관리자에게 문의해주세요.')}if (this._isNetworkError(error)){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('network/connection-failed',{component: 'ExecutionManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('네트워크 연결을 확인해주세요. 잠시 후 다시 시도해주세요.')}if (error.code === 'resource-exhausted' || error.message.includes('quota') || error.message.includes('limit')){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('server/service-unavailable',{component: 'ExecutionManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('쿼리 제한에 도달했습니다. 잠시 후 다시 시도해주세요.')}if (error.code === 'not-found' || error.code === 'firestore/not-found'){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('data/not-found',{component: 'ExecutionManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('데이터를 찾을 수 없습니다. 페이지를 새로고침하거나 다시 시도해주세요.')}throw error}setCurrentUser(user){this.currentUser = user}async executePrompt(promptId, versionId, variables, llmModel){try{if (!promptId || !versionId || !llmModel){throw new Error('프롬프트 ID, 버전 ID, LLM 모델은 필수입니다.')}if (!this.currentUser){throw new Error('로그인이 필요합니다.')}const version = await this._getVersion(promptId, versionId);let renderedPrompt;if (this.templateEngine){renderedPrompt = this.templateEngine.render(version.content, variables)}else{renderedPrompt = this._simpleRender(version.content, variables)}await this._copyToClipboard(renderedPrompt);this._openLLMSite(llmModel);const result = await this._showResultInputModal();if (!result){throw new Error('실행이 취소되었습니다.')}const executionId = await this.saveExecution({promptId: promptId, versionId: versionId, input:{template: version.content, variables: variables, rendered: renderedPrompt}, output: result, llmModel: llmModel, executionMode: 'manual'});return executionId}catch (error){console.error('❌ 프롬프트 실행 실패:', error);throw new Error(`프롬프트 실행에 실패했습니다: ${error.message}`)}}async saveExecution(executionData){try{if (!this.currentUser){throw new Error('로그인이 필요합니다.')}const executionRef = this.db .collection(`users/${this.currentUser.uid}/prompts/${executionData.promptId}/executions`) .doc();const execution ={id: executionRef.id, promptId: executionData.promptId, versionId: executionData.versionId, input: executionData.input, output: executionData.output, llmModel: executionData.llmModel, executionMode: executionData.executionMode || 'manual', rating: null, feedback: null, tags: [], executedAt: new Date(), evaluatedAt: null};await executionRef.set(execution);return executionRef.id}catch (error){console.error('❌ 실행 이력 저장 실패:',{error: error.message, stack: error.stack, errorCode: error.code, promptId: executionData.promptId, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});this._handleFirestoreQueryError(error, 'saveExecutionHistory')}}async evaluateExecution(promptId, executionId, evaluation){try{if (!promptId || !executionId){throw new Error('프롬프트 ID와 실행 ID가 필요합니다.')}if (!this.currentUser){throw new Error('로그인이 필요합니다.')}this._validateEvaluation(evaluation);await this.db .collection(`users/${this.currentUser.uid}/prompts/${promptId}/executions`) .doc(executionId) .update({rating: evaluation.rating, feedback: evaluation.feedback || null, tags: evaluation.tags || [], evaluatedAt: new Date()})}catch (error){console.error('❌ 실행 평가 실패:', error);throw new Error(`실행 평가에 실패했습니다: ${error.message}`)}}async getExecutionHistory(promptId, filters ={}){try{if (!promptId){throw new Error('프롬프트 ID가 필요합니다.')}if (!this.currentUser){throw new Error('로그인이 필요합니다.')}const cacheKey = `executionHistory_${promptId}_${JSON.stringify(filters)}`;if (this.cache.has(cacheKey)){const cached = this.cache.get(cacheKey);if (Date.now() - cached.timestamp < this.cacheTimeout){return cached.data}}if (this.pendingRequests.has(cacheKey)){return await this.pendingRequests.get(cacheKey)}const requestPromise = (async () =>{try{let query = this.db .collection(`users/${this.currentUser.uid}/prompts/${promptId}/executions`) .orderBy('executedAt', 'desc') .limit(100);if (filters.versionId){query = query.where('versionId', '==', filters.versionId)}if (filters.llmModel){query = query.where('llmModel', '==', filters.llmModel)}if (filters.minRating){query = query.where('rating', '>=', filters.minRating)}const snapshot = await query.get();const histories = snapshot.docs.map((doc) => doc.data());this.cache.set(cacheKey,{data: histories, timestamp: Date.now()});return histories}finally{this.pendingRequests.delete(cacheKey)}})();this.pendingRequests.set(cacheKey, requestPromise);return await requestPromise}catch (error){console.error('❌ 실행 이력 조회 실패:',{error: error.message, stack: error.stack, errorCode: error.code, promptId: promptId, filters: filters, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});this._handleFirestoreQueryError(error, 'getExecutionHistory')}}async _copyToClipboard(text){try{if (navigator.clipboard && navigator.clipboard.writeText){await navigator.clipboard.writeText(text);');return}const textarea = document.createElement('textarea');textarea.value = text;textarea.style.position = 'fixed';textarea.style.opacity = '0';document.body.appendChild(textarea);textarea.select();const isSuccess = document.execCommand('copy');document.body.removeChild(textarea);if (isSuccess){')}else{throw new Error('클립보드 복사 실패')}}catch (error){console.error('❌ 클립보드 복사 실패:', error);alert('클립보드 복사에 실패했습니다. 수동으로 복사해주세요.')}}_openLLMSite(llmModel){const llmUrls ={'gpt-4': 'https: 'gpt-3.5': 'https: claude: 'https: gemini: 'https: perplexity: 'https: grok: 'https:};const url = llmUrls[llmModel] || llmUrls['gpt-4'];window.open(url, '_blank')}_showResultInputModal(){return new Promise((resolve) =>{const modal = document.createElement('div');modal.className = 'result-input-modal';modal.setAttribute('role', 'dialog');modal.setAttribute('aria-labelledby', 'modal-title');modal.setAttribute('aria-modal', 'true');modal.innerHTML = ` <div class="modal-overlay"></div> <div class="modal-content"> <h3 id="modal-title">LLM 실행 결과 입력</h3> <p>LLM에서 받은 응답을 붙여넣어주세요.</p> <textarea id="llm-result" placeholder="응답 내용을 여기에 붙여넣으세요..." rows="15" aria-label="LLM 응답 입력" ></textarea> <div class="modal-actions"> <button id="save-result" class="btn btn-primary" aria-label="결과 저장"> 저장 </button> <button id="cancel-result" class="btn btn-secondary" aria-label="취소"> 취소 </button> </div> </div> `;document.body.appendChild(modal);const textarea = modal.querySelector('#llm-result');setTimeout(() => textarea.focus(), 100);modal.querySelector('#save-result').onclick = () =>{const result = textarea.value;if (result.trim()){modal.remove();resolve(result)}else{alert('결과를 입력해주세요.')}};modal.querySelector('#cancel-result').onclick = () =>{modal.remove();resolve(null)};const escHandler = (e) =>{if (e.key === 'Escape'){modal.remove();resolve(null);document.removeEventListener('keydown', escHandler)}};document.addEventListener('keydown', escHandler)})}async _getVersion(promptId, versionId){try{const doc = await this.db .collection(`users/${this.currentUser.uid}/prompts/${promptId}/versions`) .doc(versionId) .get();if (!doc.exists){throw new Error('버전을 찾을 수 없습니다.')}return doc.data()}catch (error){console.error('❌ 버전 조회 실패:', error);throw new Error(`버전 조회에 실패했습니다: ${error.message}`)}}_simpleRender(template, variables){let result = template;for (const [key, value] of Object.entries(variables)){const regex = new RegExp(`{{${key}}}`, 'g');result = result.replace(regex, value)}return result}_validateEvaluation(evaluation){if (!evaluation.rating || typeof evaluation.rating !== 'number'){throw new Error('평점은 필수입니다.')}if (evaluation.rating < 1 || evaluation.rating > 5){throw new Error('평점은 1-5 사이여야 합니다.')}}async saveExecutionHistory(executionData){try{this._validateExecutionData(executionData);if (!this.currentUser){throw new Error('로그인이 필요합니다.')}const historyRef = this.db.collection(`users/${this.currentUser.uid}/executionHistory`).doc();const historyData ={id: historyRef.id, promptId: executionData.promptId, versionId: executionData.versionId, resultText: executionData.resultText.trim(), rating: executionData.rating || 3, notes: executionData.notes?.trim() || '', executedAt: new Date(), createdAt: new Date(), updatedAt: new Date(), userId: this.currentUser.uid, userEmail: this.currentUser.email, resultLength: executionData.resultText.trim().length, hasNotes: Boolean(executionData.notes?.trim()), isDeleted: false, isArchived: false};await historyRef.set(historyData);await this._updatePromptStats(executionData.promptId, executionData.rating);return historyRef.id}catch (error){console.error('❌ 실행 이력 저장 실패:', error);throw new Error(`실행 이력 저장에 실패했습니다: ${error.message}`)}}async getExecutionHistories(options ={}){try{if (!this.currentUser){throw new Error('로그인이 필요합니다.')}const{promptId = null, limit = 20, startAfter = null}= options;const cacheKey = startAfter ? null : `executionHistories_${promptId}_${limit}`;if (cacheKey && this.cache.has(cacheKey)){const cached = this.cache.get(cacheKey);if (Date.now() - cached.timestamp < this.cacheTimeout){return cached.data}}if (cacheKey && this.pendingRequests.has(cacheKey)){return await this.pendingRequests.get(cacheKey)}const requestPromise = (async () =>{try{let query = this.db .collection(`users/${this.currentUser.uid}/executionHistory`) .where('isDeleted', '==', false) .orderBy('executedAt', 'desc') .limit(limit);if (promptId){query = query.where('promptId', '==', promptId)}if (startAfter){query = query.startAfter(startAfter)}const snapshot = await query.get();const histories = snapshot.docs.map((doc) => doc.data());const lastDoc = snapshot.docs[snapshot.docs.length - 1];const result ={histories, lastDoc, hasMore: snapshot.docs.length === limit};if (cacheKey){this.cache.set(cacheKey,{data: result, timestamp: Date.now()})}return result}finally{if (cacheKey){this.pendingRequests.delete(cacheKey)}}})();if (cacheKey){this.pendingRequests.set(cacheKey, requestPromise)}return await requestPromise}catch (error){console.error('❌ 실행 이력 조회 실패:',{error: error.message, stack: error.stack, errorCode: error.code, options: options, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});this._handleFirestoreQueryError(error, 'getExecutionHistories')}}async deleteExecutionHistory(historyId){try{if (!historyId){throw new Error('실행 이력 ID가 필요합니다.')}if (!this.currentUser){throw new Error('로그인이 필요합니다.')}await this.db.collection(`users/${this.currentUser.uid}/executionHistory`).doc(historyId).update({isDeleted: true, deletedAt: new Date(), updatedAt: new Date()})}catch (error){console.error('❌ 실행 이력 삭제 실패:', error);throw new Error(`실행 이력 삭제에 실패했습니다: ${error.message}`)}}_validateExecutionData(executionData){if (!executionData){throw new Error('실행 데이터가 필요합니다.')}if (!executionData.promptId || typeof executionData.promptId !== 'string'){throw new Error('유효한 프롬프트 ID가 필요합니다.')}if (!executionData.versionId || typeof executionData.versionId !== 'string'){throw new Error('유효한 버전 ID가 필요합니다.')}if (!executionData.resultText || typeof executionData.resultText !== 'string'){throw new Error('실행 결과 텍스트가 필요합니다.')}if (executionData.resultText.trim().length < 10){throw new Error('실행 결과는 최소 10자 이상이어야 합니다.')}if (executionData.resultText.trim().length > 5000){throw new Error('실행 결과는 최대 5000자까지 가능합니다.')}if (executionData.rating !== undefined){const rating = Number(executionData.rating);if (isNaN(rating) || rating < 1 || rating > 5){throw new Error('평가는 1-5 사이의 숫자여야 합니다.')}}if (executionData.notes && typeof executionData.notes !== 'string'){throw new Error('메모는 문자열이어야 합니다.')}if (executionData.notes && executionData.notes.length > 1000){throw new Error('메모는 최대 1000자까지 가능합니다.')}}async _updatePromptStats(promptId, rating){try{const promptRef = this.db.collection(`users/${this.currentUser.uid}/prompts`).doc(promptId);const promptDoc = await promptRef.get();if (promptDoc.exists){const promptData = promptDoc.data();const currentStats = promptData.stats ||{executionCount: 0, totalRating: 0, averageRating: 0};const newExecutionCount = currentStats.executionCount + 1;const newTotalRating = currentStats.totalRating + rating;const newAverageRating = newTotalRating / newExecutionCount;await promptRef.update({stats:{executionCount: newExecutionCount, totalRating: newTotalRating, averageRating: Math.round(newAverageRating * 10) / 10, lastExecutedAt: new Date()}, updatedAt: new Date()})}점)` )}}catch (error){console.warn('⚠️ 프롬프트 통계 업데이트 실패:', error)}}}if (typeof module !== 'undefined' && module.exports){module.exports = ExecutionManager}