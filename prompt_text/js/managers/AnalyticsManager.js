class AnalyticsManager{constructor(db, auth){if (!db || !auth){throw new Error('AnalyticsManager: db와 auth는 필수 파라미터입니다.')}this.db = db;this.auth = auth;this.currentUser = null;this.metricsCache = new Map();this.cacheTimeout = 5 * 60 * 1000}setCurrentUser(user){this.currentUser = user;this.clearCache()}async calculatePromptMetrics(promptId){try{if (!promptId){throw new Error('프롬프트 ID가 필요합니다.')}if (this.metricsCache.has(promptId)){const cached = this.metricsCache.get(promptId);if (Date.now() - cached.timestamp < this.cacheTimeout){return cached.data}}const executions = await this._getExecutions(promptId);if (executions.length === 0){return this._getEmptyMetrics()}const metrics ={totalExecutions: executions.length, averageRating: this.calculateAverage( executions.reduce((ratings, e) =>{if (e.rating !== null) ratings.push(e.rating);return ratings}, []) ), ratingDistribution: this.getRatingDistribution(executions), successRate: this.calculateSuccessRate(executions), commonTags: this.getCommonTags(executions), llmModelUsage: this.getLLMModelUsage(executions), versionPerformance: await this.getVersionPerformance(promptId)};this.metricsCache.set(promptId,{data: metrics, timestamp: Date.now()});return metrics}catch (error){console.error('❌ 메트릭 계산 실패:', error);throw new Error(`메트릭 계산에 실패했습니다: ${error.message}`)}}_calculateAverageSimple(numbers){if (!Array.isArray(numbers) || numbers.length === 0){return 0}const sum = numbers.reduce((acc, num) => acc + num, 0);return Math.round((sum / numbers.length) * 10) / 10}_getRatingDistributionSimple(executions){const distribution ={5: 0, 4: 0, 3: 0, 2: 0, 1: 0};executions.forEach((execution) =>{if (execution.rating && execution.rating >= 1 && execution.rating <= 5){distribution[execution.rating]++}});return distribution}_calculateSuccessRateSimple(executions){const ratedExecutions = executions.filter((e) => e.rating !== null);if (ratedExecutions.length === 0){return 0}const successfulExecutions = ratedExecutions.filter((e) => e.rating >= 4);return Math.round((successfulExecutions.length / ratedExecutions.length) * 100) / 100}getCommonTags(executions){const tagCounts ={};executions.forEach((execution) =>{if (execution.tags && Array.isArray(execution.tags)){execution.tags.forEach((tag) =>{tagCounts[tag] = (tagCounts[tag] || 0) + 1})}});return Object.entries(tagCounts) .sort((a, b) => b[1] - a[1]) .slice(0, 5) .map(([tag, count]) => ({tag, count}))}getLLMModelUsage(executions){const modelCounts ={};executions.forEach((execution) =>{if (execution.llmModel){modelCounts[execution.llmModel] = (modelCounts[execution.llmModel] || 0) + 1}});return modelCounts}async getVersionPerformance(promptId){try{const versions = await this._getVersions(promptId);const performance ={};for (const version of versions){const executions = await this._getExecutionsByVersion(promptId, version.id);const ratings = executions.reduce((acc, e) =>{if (e.rating !== null) acc.push(e.rating);return acc}, []);performance[version.version] ={executionCount: executions.length, averageRating: this.calculateAverage(ratings), successRate: this.calculateSuccessRate(ratings, 4)}}return performance}catch (error){console.error('❌ 버전 성과 분석 실패:', error);return{}}}async suggestImprovements(promptId){try{const metrics = await this.calculatePromptMetrics(promptId);const suggestions = [];if (metrics.averageRating < 3.5){suggestions.push({type: 'structure', priority: 'high', message: '평균 평점이 낮습니다. 프롬프트 구조를 개선하세요.', example: '명확한 지시사항과 예시를 추가하세요.'})}if (metrics.successRate < 0.7){suggestions.push({type: 'clarity', priority: 'high', message: '성공률이 낮습니다. 프롬프트를 더 명확하게 작성하세요.', example: '모호한 표현을 구체적으로 바꾸세요.'})}if (metrics.totalExecutions < 5){suggestions.push({type: 'testing', priority: 'medium', message: '실행 횟수가 적습니다. 더 많이 테스트해보세요.', example: '다양한 변수 값으로 테스트하세요.'})}return suggestions}catch (error){console.error('❌ 개선 제안 생성 실패:', error);return []}}async _getExecutions(promptId){if (!this.currentUser){return []}const snapshot = await this.db.collection(`users/${this.currentUser.uid}/prompts/${promptId}/executions`).get();return snapshot.docs.map((doc) => doc.data())}async _getVersions(promptId){if (!this.currentUser){return []}const snapshot = await this.db.collection(`users/${this.currentUser.uid}/prompts/${promptId}/versions`).get();return snapshot.docs.map((doc) => doc.data())}async _getExecutionsByVersion(promptId, versionId){if (!this.currentUser){return []}const snapshot = await this.db .collection(`users/${this.currentUser.uid}/prompts/${promptId}/executions`) .where('versionId', '==', versionId) .get();return snapshot.docs.map((doc) => doc.data())}_getEmptyMetrics(){return{totalExecutions: 0, averageRating: 0, ratingDistribution:{5: 0, 4: 0, 3: 0, 2: 0, 1: 0}, successRate: 0, commonTags: [], llmModelUsage:{}, versionPerformance:{}}}calculateAverage(ratings){try{if (ratings === null || ratings === undefined){console.warn('⚠️ 평점 데이터가 없습니다.');return 0}if (!Array.isArray(ratings)){console.error('❌ 평점 데이터는 배열이어야 합니다.');return 0}if (ratings.length === 0){return 0}const validRatings = ratings.filter((rating) =>{if (typeof rating !== 'number'){console.warn(`⚠️ 유효하지 않은 평점 타입: ${typeof rating}`);return false}if (isNaN(rating)){console.warn('⚠️ NaN 평점이 발견되었습니다.');return false}if (rating < 1 || rating > 5){console.warn(`⚠️ 범위를 벗어난 평점: ${rating}`);return false}return true});if (validRatings.length === 0){console.warn('⚠️ 유효한 평점이 없습니다.');return 0}const sum = validRatings.reduce((accumulator, rating) => accumulator + rating, 0);if (validRatings.length === 0){return 0}const average = sum / validRatings.length;const roundedAverage = Math.round(average * 10) / 10;`);return roundedAverage}catch (error){console.error('❌ 평균 계산 중 오류가 발생했습니다:', error);console.error('스택 트레이스:', error.stack);return 0}}getRatingDistribution(ratings){try{const distribution ={5: 0, 4: 0, 3: 0, 2: 0, 1: 0};if (ratings === null || ratings === undefined){console.warn('⚠️ 평점 데이터가 없습니다.');return distribution}if (!Array.isArray(ratings)){console.error('❌ 평점 데이터는 배열이어야 합니다.');return distribution}if (ratings.length === 0){return distribution}let validCount = 0;let invalidCount = 0;ratings.forEach((rating, index) =>{if (typeof rating !== 'number'){console.warn(`⚠️ [${index}] 유효하지 않은 평점 타입: ${typeof rating}`);invalidCount++;return}if (isNaN(rating)){console.warn(`⚠️ [${index}] NaN 평점이 발견되었습니다.`);invalidCount++;return}if (rating >= 1 && rating <= 5){const roundedRating = Math.round(rating);distribution[roundedRating]++;validCount++}else{console.warn(`⚠️ [${index}] 범위를 벗어난 평점: ${rating}`);invalidCount++}});return distribution}catch (error){console.error('❌ 평점 분포 계산 중 오류가 발생했습니다:', error);console.error('스택 트레이스:', error.stack);return{5: 0, 4: 0, 3: 0, 2: 0, 1: 0}}}calculateSuccessRate(ratings, threshold = 4){try{if (!Array.isArray(ratings) || ratings.length === 0){return 0}const validRatings = ratings.filter((r) => typeof r === 'number' && r >= 1 && r <= 5);if (validRatings.length === 0){return 0}const successCount = validRatings.filter((r) => r >= threshold).length;const successRate = (successCount / validRatings.length) * 100;return Math.round(successRate * 10) / 10}catch (error){console.error('❌ 성공률 계산 실패:', error);return 0}}async calculateRatingStatistics(promptId){try{if (!promptId){throw new Error('프롬프트 ID가 필요합니다.')}if (!this.currentUser){throw new Error('로그인이 필요합니다.')}const executions = await this.db .collection(`users/${this.currentUser.uid}/executionHistory`) .where('promptId', '==', promptId) .where('isDeleted', '==', false) .get();const ratings = executions.docs .map((doc) => doc.data().rating) .filter((r) => r !== null && r !== undefined);const statistics ={totalExecutions: executions.docs.length, totalRatings: ratings.length, averageRating: this.calculateAverage(ratings), ratingDistribution: this.getRatingDistribution(ratings), successRate: this.calculateSuccessRate(ratings, 4), highRatingRate: this.calculateSuccessRate(ratings, 5), medianRating: this._calculateMedian(ratings), modeRating: this._calculateMode(ratings), standardDeviation: this._calculateStandardDeviation(ratings)};return statistics}catch (error){console.error('❌ 평가 통계 계산 실패:', error);throw new Error(`평가 통계 계산에 실패했습니다: ${error.message}`)}}_calculateMedian(ratings){if (!ratings || ratings.length === 0) return 0;const sorted = [...ratings].sort((a, b) => a - b);const mid = Math.floor(sorted.length / 2);if (sorted.length % 2 === 0){return (sorted[mid - 1] + sorted[mid]) / 2}else{return sorted[mid]}}_calculateMode(ratings){if (!ratings || ratings.length === 0) return 0;const frequency ={};let maxFreq = 0;let mode = 0;ratings.forEach((rating) =>{frequency[rating] = (frequency[rating] || 0) + 1;if (frequency[rating] > maxFreq){maxFreq = frequency[rating];mode = rating}});return mode}_calculateStandardDeviation(ratings){if (!ratings || ratings.length === 0) return 0;const avg = this.calculateAverage(ratings);const squareDiffs = ratings.map((rating) => Math.pow(rating - avg, 2));const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / ratings.length;return Math.round(Math.sqrt(avgSquareDiff) * 100) / 100}clearCache(){this.metricsCache.clear()}}if (typeof module !== 'undefined' && module.exports){module.exports = AnalyticsManager}