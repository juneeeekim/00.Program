class VersionManager{constructor(db, auth){if (!db || !auth){throw new Error('VersionManager: dbì™€ authëŠ” í•„ìˆ˜ íŒŒë¼ë¯¸í„°ì…ë‹ˆë‹¤.')}this.db = db;this.auth = auth;this.currentUser = null;this.dmp = null;this.cache = new Map();this.cacheTimeout = 5 * 60 * 1000;this.pendingRequests = new Map()}_isNetworkError(error){const networkErrorCodes = ['unavailable', 'deadline-exceeded', 'resource-exhausted', 'cancelled'];return ( networkErrorCodes.includes(error.code) || error.message.includes('network') || error.message.includes('offline') )}_handleFirestoreQueryError(error, operation = 'ì¿¼ë¦¬ ì‹¤í–‰'){if (error.code === 'permission-denied' || error.code === 'firestore/permission-denied'){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('firestore/permission-denied',{component: 'VersionManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. ë¡œê·¸ì¸ ìƒíƒœë¥¼ í™•ì¸í•˜ê±°ë‚˜ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.')}if (this._isNetworkError(error)){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('network/connection-failed',{component: 'VersionManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.')}if (error.code === 'resource-exhausted' || error.message.includes('quota') || error.message.includes('limit')){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('server/service-unavailable',{component: 'VersionManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('ì¿¼ë¦¬ ì œí•œì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.')}if (error.code === 'not-found' || error.code === 'firestore/not-found'){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('data/not-found',{component: 'VersionManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ê±°ë‚˜ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.')}throw error}setCurrentUser(user){this.currentUser = user}async createVersion(promptId, versionData){try{if (!promptId){throw new Error('í”„ë¡¬í”„íŠ¸ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.')}if (!this.currentUser){throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.')}this._validateVersionData(versionData);const currentVersion = await this._getCurrentVersion(promptId);const newVersionNumber = this.incrementVersion(currentVersion.version, versionData.versionType);const versionRef = this.db.collection(`users/${this.currentUser.uid}/prompts/${promptId}/versions`).doc();const newVersion ={id: versionRef.id, version: newVersionNumber, content: versionData.content, variables: versionData.variables || [], changelog: versionData.changelog, createdAt: new Date(), createdBy: this.currentUser.uid};await versionRef.set(newVersion);await this.db.collection(`users/${this.currentUser.uid}/prompts`).doc(promptId).update({currentVersion: newVersionNumber, updatedAt: new Date()});`);return versionRef.id}catch (error){console.error('âŒ ë²„ì „ ìƒì„± ì‹¤íŒ¨:',{error: error.message, stack: error.stack, errorCode: error.code, promptId: promptId, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});try{this._handleFirestoreQueryError(error, 'createVersion')}catch (handledError){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('version/create-failed',{component: 'VersionManager', method: 'createVersion', promptId: promptId, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw handledError}}}incrementVersion(currentVersion, type){try{const versionRegex = /^v(\d+)\.(\d+)\.(\d+)$/;const match = currentVersion.match(versionRegex);if (!match){throw new Error(`ì˜ëª»ëœ ë²„ì „ í˜•ì‹ì…ë‹ˆë‹¤: ${currentVersion}`)}let [, major, minor, patch] = match.map(Number);switch (type){case 'major': major += 1;minor = 0;patch = 0;break;case 'minor': minor += 1;patch = 0;break;case 'patch': patch += 1;break;default: throw new Error(`ì˜ëª»ëœ ë²„ì „ íƒ€ì…ì…ë‹ˆë‹¤: ${type}`)}const newVersion = `v${major}.${minor}.${patch}`;`);return newVersion}catch (error){console.error('âŒ ë²„ì „ ì¦ê°€ ì‹¤íŒ¨:', error);throw error}}async compareVersions(promptId, versionId1, versionId2){try{if (!promptId || !versionId1 || !versionId2){throw new Error('í”„ë¡¬í”„íŠ¸ IDì™€ ë‘ ë²„ì „ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.')}const [version1, version2] = await Promise.all([ this.getVersionByIds(promptId, versionId1), this.getVersionByIds(promptId, versionId2) ]);const textDiff = this._simpleTextDiff(version1.content, version2.content);const variablesDiff = this._compareVariables(version1.variables, version2.variables);const performanceComparison ={version1:{executionCount: 0, avgRating: 0}, version2:{executionCount: 0, avgRating: 0}};return{version1:{id: version1.id, version: version1.version, createdAt: version1.createdAt}, version2:{id: version2.id, version: version2.version, createdAt: version2.createdAt}, textDiff: textDiff, variablesDiff: variablesDiff, performance: performanceComparison}}catch (error){console.error('âŒ ë²„ì „ ë¹„êµ ì‹¤íŒ¨:', error);throw new Error(`ë²„ì „ ë¹„êµì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ${error.message}`)}}async getVersionByIds(promptId, versionId){try{if (!promptId || !versionId){throw new Error('í”„ë¡¬í”„íŠ¸ IDì™€ ë²„ì „ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.')}if (!this.currentUser){throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.')}const doc = await this.db .collection(`users/${this.currentUser.uid}/prompts/${promptId}/versions`) .doc(versionId) .get();if (!doc.exists){throw new Error('ë²„ì „ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')}return doc.data()}catch (error){console.error('âŒ ë²„ì „ ì¡°íšŒ ì‹¤íŒ¨:',{error: error.message, stack: error.stack, errorCode: error.code, promptId: promptId, versionId: versionId, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});try{this._handleFirestoreQueryError(error, 'getVersionByIds')}catch (handledError){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('version/not-found',{component: 'VersionManager', method: 'getVersionByIds', promptId: promptId, versionId: versionId, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw handledError}}}async getVersions(promptId){try{if (!promptId){throw new Error('í”„ë¡¬í”„íŠ¸ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.')}if (!this.currentUser){throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.')}const cacheKey = `versions_${promptId}`;if (this.cache.has(cacheKey)){const cached = this.cache.get(cacheKey);if (Date.now() - cached.timestamp < this.cacheTimeout){return cached.data}}if (this.pendingRequests.has(cacheKey)){return await this.pendingRequests.get(cacheKey)}const requestPromise = (async () =>{try{const snapshot = await this.db .collection(`users/${this.currentUser.uid}/prompts/${promptId}/versions`) .orderBy('createdAt', 'desc') .limit(100) .get();const versions = snapshot.docs.map((doc) => doc.data());this.cache.set(cacheKey,{data: versions, timestamp: Date.now()});return versions}finally{this.pendingRequests.delete(cacheKey)}})();this.pendingRequests.set(cacheKey, requestPromise);return await requestPromise}catch (error){console.error('âŒ ë²„ì „ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:',{error: error.message, stack: error.stack, errorCode: error.code, promptId: promptId, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});this._handleFirestoreQueryError(error, 'getVersions')}}async switchVersion(promptId, targetVersionId){try{if (!promptId || !targetVersionId){throw new Error('í”„ë¡¬í”„íŠ¸ IDì™€ íƒ€ê²Ÿ ë²„ì „ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.')}if (!this.currentUser){throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.')}const targetVersion = await this.getVersionByIds(promptId, targetVersionId);if (!targetVersion){throw new Error('ë²„ì „ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')}await this.db.collection(`users/${this.currentUser.uid}/prompts`).doc(promptId).update({currentVersion: targetVersion.version, updatedAt: new Date()});return targetVersion}catch (error){console.error('âŒ ë²„ì „ ì „í™˜ ì‹¤íŒ¨:',{error: error.message, stack: error.stack, errorCode: error.code, promptId: promptId, targetVersionId: targetVersionId, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});this._handleFirestoreQueryError(error, 'switchVersion')}}async getCurrentActiveVersion(promptId){try{if (!promptId){throw new Error('í”„ë¡¬í”„íŠ¸ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.')}if (!this.currentUser){throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.')}const promptDoc = await this.db.collection(`users/${this.currentUser.uid}/prompts`).doc(promptId).get();if (!promptDoc.exists){throw new Error('í”„ë¡¬í”„íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')}const promptData = promptDoc.data();const currentVersionNumber = promptData.currentVersion;const versionsSnapshot = await this.db .collection(`users/${this.currentUser.uid}/prompts/${promptId}/versions`) .where('version', '==', currentVersionNumber) .limit(1) .get();if (versionsSnapshot.empty){throw new Error('í˜„ì¬ ë²„ì „ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')}return versionsSnapshot.docs[0].data()}catch (error){console.error('âŒ í˜„ì¬ ë²„ì „ ì¡°íšŒ ì‹¤íŒ¨:',{error: error.message, stack: error.stack, errorCode: error.code, promptId: promptId, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});this._handleFirestoreQueryError(error, 'getCurrentActiveVersion')}}async _getCurrentVersion(promptId){const versions = await this.getVersions(promptId);if (versions.length === 0){throw new Error('ë²„ì „ì´ ì—†ìŠµë‹ˆë‹¤.')}return versions[0]}_validateVersionData(data){if (!data.versionType || !['major', 'minor', 'patch'].includes(data.versionType)){throw new Error('ë²„ì „ íƒ€ì…ì€ major, minor, patch ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤.')}if (!data.changelog || typeof data.changelog !== 'string'){throw new Error('ë³€ê²½ ì‚¬í•­ ì„¤ëª…ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.')}if (!data.content || typeof data.content !== 'string'){throw new Error('í…œí”Œë¦¿ ë‚´ìš©ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.')}}_simpleTextDiff(text1, text2){return{added: text2.length - text1.length, removed: 0, unchanged: Math.min(text1.length, text2.length)}}_compareVariables(vars1, vars2){const vars1Map = new Map(vars1.map(v => [v.name, v]));const vars2Map = new Map(vars2.map(v => [v.name, v]));const added = [];const removed = [];const modified = [];for (const v2 of vars2){const v1 = vars1Map.get(v2.name);if (!v1){added.push(v2)}else if (JSON.stringify(v1) !== JSON.stringify(v2)){modified.push(v2)}}for (const v1 of vars1){if (!vars2Map.has(v1.name)){removed.push(v1)}}return{added, removed, modified}}async canRollback(promptId, targetVersionId){try{if (!promptId || !targetVersionId){return{canRollback: false, reason: 'í”„ë¡¬í”„íŠ¸ IDì™€ ë²„ì „ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.', impact: null}}if (!this.currentUser){return{canRollback: false, reason: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.', impact: null}}const targetVersionRef = this.db .collection(`users/${this.currentUser.uid}/prompts/${promptId}/versions`) .doc(targetVersionId);const targetVersionDoc = await targetVersionRef.get();if (!targetVersionDoc.exists){return{canRollback: false, reason: 'ë¡¤ë°±í•  ë²„ì „ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', impact: null}}const targetVersion = targetVersionDoc.data();const currentVersions = await this.getVersions(promptId);if (!currentVersions || currentVersions.length === 0){return{canRollback: false, reason: 'ë²„ì „ì´ ì—†ìŠµë‹ˆë‹¤.', impact: null}}const currentVersion = currentVersions.sort((a, b) => this._compareVersionNumbers(b.version, a.version))[0];if (!currentVersion){return{canRollback: false, reason: 'í˜„ì¬ ë²„ì „ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', impact: null}}if (currentVersion.id === targetVersionId){return{canRollback: false, reason: 'ì´ë¯¸ í˜„ì¬ ë²„ì „ì…ë‹ˆë‹¤.', impact: null}}const impact ={contentChanged: targetVersion.content !== currentVersion.content, variablesChanged: JSON.stringify(targetVersion.variables || []) !== JSON.stringify(currentVersion.variables || []), versionCount: currentVersions.length, targetVersion: targetVersion.version, currentVersion: currentVersion.version};return{canRollback: true, reason: 'ë¡¤ë°± ê°€ëŠ¥í•©ë‹ˆë‹¤.', impact: impact}}catch (error){console.error('âŒ ë¡¤ë°± ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸ ì‹¤íŒ¨:', error);return{canRollback: false, reason: `í™•ì¸ ì‹¤íŒ¨: ${error.message}`, impact: null}}}async rollbackToVersion(promptId, targetVersionId, options ={}){try{if (!promptId || !targetVersionId){throw new Error('í”„ë¡¬í”„íŠ¸ IDì™€ ë²„ì „ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.')}if (!this.currentUser){throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.')}const checkResult = await this.canRollback(promptId, targetVersionId);if (!checkResult.canRollback){throw new Error(checkResult.reason)}const targetVersion = await this.getVersionByIds(promptId, targetVersionId);if (!targetVersion){throw new Error('ëŒ€ìƒ ë²„ì „ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')}const currentVersion = await this.getCurrentVersion(promptId);const autoChangelog = this._generateRollbackChangelog(currentVersion, targetVersion, options.reason);const newVersionData ={versionType: 'patch', changelog: autoChangelog, content: targetVersion.content, variables: targetVersion.variables, isRollback: true, rollbackFrom: currentVersion.id, rollbackTo: targetVersion.id, rollbackReason: options.reason || 'ì´ì „ ë²„ì „ìœ¼ë¡œ ë¡¤ë°±'};const newVersionId = await this._createVersionWithTransaction(promptId, newVersionData);return newVersionId}catch (error){console.error('âŒ ë¡¤ë°± ì‹¤íŒ¨:',{error: error.message, stack: error.stack, promptId: promptId, targetVersionId: targetVersionId, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('version/rollback-failed',{component: 'VersionManager', method: 'rollbackToVersion', promptId: promptId, targetVersionId: targetVersionId, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('ë²„ì „ ë¡¤ë°±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”. ë¬¸ì œê°€ ê³„ì†ë˜ë©´ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.')}}async _createVersionWithTransaction(promptId, versionData){try{const result = await this.db.runTransaction(async (transaction) =>{const promptRef = this.db.collection(`users/${this.currentUser.uid}/prompts`).doc(promptId);const promptDoc = await transaction.get(promptRef);if (!promptDoc.exists){throw new Error('í”„ë¡¬í”„íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')}const promptData = promptDoc.data();const currentVersionId = promptData.currentVersionId;let currentVersion = null;if (currentVersionId){const currentVersionRef = this.db .collection(`users/${this.currentUser.uid}/prompts/${promptId}/versions`) .doc(currentVersionId);const currentVersionDoc = await transaction.get(currentVersionRef);if (currentVersionDoc.exists){currentVersion = currentVersionDoc.data()}}const newVersionNumber = this._incrementVersion( currentVersion ? currentVersion.version : 'v0.0.0', versionData.versionType || 'patch' );const newVersionRef = this.db .collection(`users/${this.currentUser.uid}/prompts/${promptId}/versions`) .doc();const newVersion ={id: newVersionRef.id, version: newVersionNumber, content: versionData.content, variables: versionData.variables || [], changelog: versionData.changelog || '', createdAt: new Date(), createdBy: this.currentUser.uid, createdByEmail: this.currentUser.email, isActive: true, isCurrent: true, isRollback: versionData.isRollback || false, rollbackFrom: versionData.rollbackFrom || null, rollbackTo: versionData.rollbackTo || null, rollbackReason: versionData.rollbackReason || null};transaction.set(newVersionRef, newVersion);if (currentVersionId){const oldVersionRef = this.db .collection(`users/${this.currentUser.uid}/prompts/${promptId}/versions`) .doc(currentVersionId);transaction.update(oldVersionRef,{isCurrent: false})}transaction.update(promptRef,{currentVersionId: newVersionRef.id, updatedAt: new Date()});return newVersionRef.id});return result}catch (error){console.error('âŒ íŠ¸ëœì­ì…˜ ì‹¤íŒ¨:', error);throw error}}_generateRollbackChangelog(currentVersion, targetVersion, reason){const lines = [];lines.push(`ğŸ”„ ë²„ì „ ë¡¤ë°±: ${currentVersion.version}â†’ ${targetVersion.version}`);lines.push('');if (reason){lines.push(`**ë¡¤ë°± ì‚¬ìœ :** ${reason}`);lines.push('')}lines.push('**ë³€ê²½ ì‚¬í•­:**');if (currentVersion.content !== targetVersion.content){lines.push('- í…œí”Œë¦¿ ë‚´ìš©ì´ ì´ì „ ë²„ì „ìœ¼ë¡œ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤.')}const currentVars = JSON.stringify(currentVersion.variables || []);const targetVars = JSON.stringify(targetVersion.variables || []);if (currentVars !== targetVars){lines.push('- ë³€ìˆ˜ ì •ì˜ê°€ ì´ì „ ë²„ì „ìœ¼ë¡œ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤.')}lines.push('');lines.push(`**ì›ë³¸ ë²„ì „:** ${targetVersion.version}`);lines.push(`**ì›ë³¸ ìƒì„±ì¼:** ${targetVersion.createdAt.toDate().toLocaleString('ko-KR')}`);if (targetVersion.changelog){lines.push('');lines.push('**ì›ë³¸ ë³€ê²½ ì‚¬í•­:**');lines.push(targetVersion.changelog)}return lines.join('\n')}}if (typeof module !== 'undefined' && module.exports){module.exports = VersionManager}