class PromptManager{static MAX_TITLE_LENGTH = 100;static MIN_TITLE_LENGTH = 1;static MAX_CONTENT_LENGTH = 10000;static MIN_CONTENT_LENGTH = 1;static MAX_DESCRIPTION_LENGTH = 500;static MAX_TAGS_COUNT = 10;static MAX_TAG_LENGTH = 20;static DEFAULT_LIMIT = 20;static CACHE_TIMEOUT_MS = 5 * 60 * 1000;static MAX_RETRIES = 3;static RETRY_DELAY_MS = 1000;constructor(db, auth){if (!db || !auth){throw new Error('PromptManager: db와 auth는 필수 파라미터입니다.')}this.db = db;this.auth = auth;this.currentUser = null;this.prompts = [];this.cache = new Map();this.cacheTimeout = PromptManager.CACHE_TIMEOUT_MS;this.pendingRequests = new Map();this.listeners = new Map();this.optimisticUpdates = new Map();this.isOnline = navigator.onLine;this.offlineQueue = [];this._setupNetworkMonitoring();this._enableOfflinePersistence()}setCurrentUser(user){this.currentUser = user;this.clearCache()}async createPrompt(promptData){try{this._validatePromptData(promptData);if (!this.currentUser){throw new Error('로그인이 필요합니다.')}const promptRef = this._createPromptRef();const prompt = this._buildPromptData(promptRef.id, promptData);if (!this.isOnline){return this._handleOfflineCreate(promptRef, prompt, promptData)}await this._savePromptToFirestore(promptRef, prompt);await this._createInitialVersion(promptRef.id,{content: promptData.content, variables: promptData.variables || []});this.clearCache();`);return promptRef.id}catch (error){return this._handleCreateError(error)}}_createPromptRef(){return this.db.collection(`users/${this.currentUser.uid}/prompts`).doc()}_buildPromptData(promptId, promptData){return{id: promptId, userId: this.currentUser.uid, title: promptData.title.trim(), description: promptData.description?.trim() || '', category: promptData.category, tags: promptData.tags || [], currentVersion: 'v1.0.0', isPublic: promptData.isPublic || false, isDeleted: false, createdAt: new Date(), updatedAt: new Date()}}_handleOfflineCreate(promptRef, prompt, promptData){this.offlineQueue.push({type: 'create', data:{promptRef, prompt, versionData:{content: promptData.content, variables: promptData.variables || []}}});return promptRef.id}async _savePromptToFirestore(promptRef, prompt){try{await this._retryOperation(async () =>{await promptRef.set(prompt)}, 3)}catch (error){console.error('❌ Firestore 저장 실패:',{error: error.message, stack: error.stack, errorCode: error.code, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});this._handleFirestoreQueryError(error, '_savePromptToFirestore')}}_handleCreateError(error){console.error('❌ 프롬프트 생성 실패:',{error: error.message, stack: error.stack, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});if (this._isNetworkError(error)){throw new Error('네트워크 연결을 확인해주세요. 오프라인 상태에서는 작업이 자동으로 저장되며, 연결이 복구되면 자동으로 동기화됩니다.')}if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('prompt/create-failed',{component: 'PromptManager', method: 'createPrompt', originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('프롬프트 생성에 실패했습니다. 입력 내용을 확인하고 다시 시도해주세요. 네트워크 연결을 확인해주세요.')}async updatePrompt(promptId, updates, optimistic = true){try{this._validateUpdateInput(promptId);const allowedUpdates = this._filterAllowedUpdates(updates);allowedUpdates.updatedAt = new Date();if (optimistic){this._applyOptimisticUpdate(promptId, allowedUpdates)}if (!this.isOnline){return this._handleOfflineUpdate(promptId, allowedUpdates)}await this._saveUpdateToFirestore(promptId, allowedUpdates, optimistic)}catch (error){return this._handleUpdateError(error, promptId, optimistic)}}_validateUpdateInput(promptId){if (!promptId){throw new Error('프롬프트 ID가 필요합니다.')}if (!this.currentUser){throw new Error('로그인이 필요합니다.')}}_filterAllowedUpdates(updates){const allowedFields = ['title', 'description', 'category', 'tags', 'isPublic'];const filteredUpdates ={};for (const field of allowedFields){if (updates[field] !== undefined){filteredUpdates[field] = updates[field]}}return filteredUpdates}_applyOptimisticUpdate(promptId, filteredUpdates){const currentData = this.cache.get(promptId)?.data ||{};const optimisticData ={...currentData, ...filteredUpdates};this.optimisticUpdates.set(promptId,{data: optimisticData, timestamp: Date.now()});this.cache.set(promptId,{data: optimisticData, timestamp: Date.now()})}_handleOfflineUpdate(promptId, filteredUpdates){this.offlineQueue.push({type: 'update', data:{promptId, updates: filteredUpdates}})}async _saveUpdateToFirestore(promptId, filteredUpdates, optimistic){try{await this._retryOperation(async () =>{await this.db.collection(`users/${this.currentUser.uid}/prompts`).doc(promptId).update(filteredUpdates)}, 3);this.optimisticUpdates.delete(promptId)}catch (error){console.error('❌ Firestore 업데이트 실패:',{error: error.message, stack: error.stack, errorCode: error.code, promptId: promptId, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});if (optimistic){this._rollbackOptimisticUpdate(promptId)}this._handleFirestoreQueryError(error, '_saveUpdateToFirestore')}}_rollbackOptimisticUpdate(promptId){this.optimisticUpdates.delete(promptId);this.cache.delete(promptId)}_handleUpdateError(error, promptId, optimistic){console.error('❌ 프롬프트 수정 실패:',{error: error.message, stack: error.stack, promptId: promptId, userId: this.currentUser?.uid, optimistic: optimistic, timestamp: new Date().toISOString()});if (this._isNetworkError(error)){throw new Error('네트워크 연결을 확인해주세요. 오프라인 상태에서는 작업이 자동으로 저장되며, 연결이 복구되면 자동으로 동기화됩니다.')}if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('prompt/update-failed',{component: 'PromptManager', method: 'updatePrompt', promptId: promptId, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('프롬프트 수정에 실패했습니다. 입력 내용을 확인하고 다시 시도해주세요.')}async deletePrompt(promptId){try{if (!promptId){throw new Error('프롬프트 ID가 필요합니다.')}if (!this.currentUser){throw new Error('로그인이 필요합니다.')}if (!this.isOnline){this.offlineQueue.push({type: 'delete', data:{promptId}});this.cache.delete(promptId);return}await this._retryOperation(async () =>{await this.db.collection(`users/${this.currentUser.uid}/prompts`).doc(promptId).update({isDeleted: true, deletedAt: new Date(), updatedAt: new Date()})}, 3);this.cache.delete(promptId)}catch (error){console.error('❌ 프롬프트 삭제 실패:',{error: error.message, stack: error.stack, errorCode: error.code, promptId: promptId, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});this._handleFirestoreQueryError(error, 'deletePrompt')}}async getPromptById(promptId){try{if (!promptId){throw new Error('프롬프트 ID가 필요합니다.')}if (this.cache.has(promptId)){const cached = this.cache.get(promptId);if (Date.now() - cached.timestamp < this.cacheTimeout){return cached.data}}if (this.pendingRequests.has(promptId)){return await this.pendingRequests.get(promptId)}if (!this.currentUser){throw new Error('로그인이 필요합니다.')}const requestPromise = (async () =>{try{const doc = await this.db .collection(`users/${this.currentUser.uid}/prompts`) .doc(promptId) .get();if (!doc.exists){throw new Error('프롬프트를 찾을 수 없습니다.')}const promptData = doc.data();this.cache.set(promptId,{data: promptData, timestamp: Date.now()});return promptData}finally{this.pendingRequests.delete(promptId)}})();this.pendingRequests.set(promptId, requestPromise);return await requestPromise}catch (error){console.error('❌ 프롬프트 조회 실패:',{error: error.message, stack: error.stack, errorCode: error.code, promptId: promptId, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});try{this._handleFirestoreQueryError(error, 'getPromptById')}catch (handledError){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('prompt/not-found',{component: 'PromptManager', method: 'getPromptById', promptId: promptId, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw handledError}}}async getPrompts(options ={}){try{if (!this.currentUser){throw new Error('로그인이 필요합니다.')}const{limit = PromptManager.DEFAULT_LIMIT, category = null, tags = null, includeDeleted = false}= options;const cacheKey = `prompts_${JSON.stringify({limit, category, tags, includeDeleted})}`;if (this.cache.has(cacheKey)){const cached = this.cache.get(cacheKey);if (Date.now() - cached.timestamp < this.cacheTimeout){return cached.data}}if (this.pendingRequests.has(cacheKey)){return await this.pendingRequests.get(cacheKey)}const requestPromise = (async () =>{try{let query = this.db .collection(`users/${this.currentUser.uid}/prompts`) .orderBy('createdAt', 'desc') .limit(limit);if (!includeDeleted){query = query.where('isDeleted', '==', false)}if (category){query = query.where('category', '==', category)}if (tags && tags.length > 0){query = query.where('tags', 'array-contains-any', tags)}const snapshot = await query.get();const prompts = snapshot.docs.map((doc) => doc.data());this.cache.set(cacheKey,{data: prompts, timestamp: Date.now()});return prompts}finally{this.pendingRequests.delete(cacheKey)}})();this.pendingRequests.set(cacheKey, requestPromise);return await requestPromise}catch (error){console.error('❌ 프롬프트 목록 조회 실패:',{error: error.message, stack: error.stack, errorCode: error.code, options: options, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});this._handleFirestoreQueryError(error, 'getPrompts')}}_validatePromptData(data){this._validateTitle(data.title);this._validateCategory(data.category);this._validateContent(data.content);if (data.description){this._validateDescription(data.description)}if (data.tags){this._validateTags(data.tags)}}_validateTitle(title){if (!title || typeof title !== 'string'){throw new Error('제목은 필수 항목입니다.')}const trimmedTitle = title.trim();if (trimmedTitle.length < PromptManager.MIN_TITLE_LENGTH || trimmedTitle.length > PromptManager.MAX_TITLE_LENGTH){throw new Error(`제목은 ${PromptManager.MIN_TITLE_LENGTH}-${PromptManager.MAX_TITLE_LENGTH}자 사이여야 합니다.`)}}_validateCategory(category){if (!category || typeof category !== 'string'){throw new Error('카테고리는 필수 항목입니다.')}}_validateContent(content){if (!content || typeof content !== 'string'){throw new Error('템플릿 내용은 필수 항목입니다.')}const trimmedContent = content.trim();if (trimmedContent.length < PromptManager.MIN_CONTENT_LENGTH || trimmedContent.length > PromptManager.MAX_CONTENT_LENGTH){throw new Error(`템플릿 내용은 ${PromptManager.MIN_CONTENT_LENGTH}-${PromptManager.MAX_CONTENT_LENGTH}자 사이여야 합니다.`)}}_validateDescription(description){if (description.length > PromptManager.MAX_DESCRIPTION_LENGTH){throw new Error(`설명은 최대 ${PromptManager.MAX_DESCRIPTION_LENGTH}자까지 가능합니다.`)}}_validateTags(tags){if (!Array.isArray(tags)){throw new Error('태그는 배열이어야 합니다.')}if (tags.length > PromptManager.MAX_TAGS_COUNT){throw new Error(`태그는 최대 ${PromptManager.MAX_TAGS_COUNT}개까지 가능합니다.`)}for (const tag of tags){if (typeof tag !== 'string' || tag.length > PromptManager.MAX_TAG_LENGTH){throw new Error(`각 태그는 최대 ${PromptManager.MAX_TAG_LENGTH}자까지 가능합니다.`)}}}async _createInitialVersion(promptId, versionData){try{const versionRef = this.db.collection(`users/${this.currentUser.uid}/prompts/${promptId}/versions`).doc();await versionRef.set({id: versionRef.id, version: 'v1.0.0', content: versionData.content, variables: versionData.variables, changelog: '초기 버전', createdAt: new Date(), createdBy: this.currentUser.uid})}catch (error){console.error('❌ 초기 버전 생성 실패:', error);throw new Error(`초기 버전 생성에 실패했습니다: ${error.message}`)}}startRealtimeSync(callback, options ={}){try{if (!this.currentUser){throw new Error('로그인이 필요합니다.')}const{includeDeleted = false, category = null, limit = 50}= options;let query = this.db .collection(`users/${this.currentUser.uid}/prompts`) .orderBy('updatedAt', 'desc') .limit(limit);if (!includeDeleted){query = query.where('isDeleted', '==', false)}if (category){query = query.where('category', '==', category)}const unsubscribe = query.onSnapshot( (snapshot) =>{const changes = this._processSnapshotChanges(snapshot);if (callback && typeof callback === 'function'){callback( changes, snapshot.docs.map((doc) => doc.data()) )}this._logRealtimeSync(changes)}, (error) =>{console.error('❌ 실시간 동기화 에러:', error);if (callback && typeof callback === 'function'){callback({error: error.message}, [])}});const listenerId = `listener_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;this.listeners.set(listenerId, unsubscribe);return listenerId}catch (error){console.error('❌ 실시간 동기화 시작 실패:', error);throw new Error(`실시간 동기화 시작에 실패했습니다: ${error.message}`)}}stopRealtimeSync(listenerId){try{if (!listenerId){throw new Error('리스너 ID가 필요합니다.')}const unsubscribe = this.listeners.get(listenerId);if (unsubscribe){unsubscribe();this.listeners.delete(listenerId)}else{console.warn(`⚠️ 리스너를 찾을 수 없습니다: ${listenerId}`)}}catch (error){console.error('❌ 실시간 동기화 중지 실패:', error)}}stopAllRealtimeSync(){try{this.listeners.forEach((unsubscribe, listenerId) =>{unsubscribe()});this.listeners.clear()}catch (error){console.error('❌ 실시간 동기화 중지 실패:', error)}}async processOfflineQueue(){if (this.offlineQueue.length === 0){return}const queue = [...this.offlineQueue];this.offlineQueue = [];for (const operation of queue){try{if (operation.type === 'create'){const{promptRef, prompt, versionData}= operation.data;await promptRef.set(prompt);await this._createInitialVersion(prompt.id, versionData);: ${prompt.id}`)}else if (operation.type === 'update'){const{promptId, updates}= operation.data;await this.db.collection(`users/${this.currentUser.uid}/prompts`).doc(promptId).update(updates);: ${promptId}`)}else if (operation.type === 'delete'){const{promptId}= operation.data;await this.db.collection(`users/${this.currentUser.uid}/prompts`).doc(promptId).update({isDeleted: true, deletedAt: new Date(), updatedAt: new Date()});: ${promptId}`)}}catch (error){console.error('❌ 오프라인 작업 실패:', error);this.offlineQueue.push(operation)}}}_setupNetworkMonitoring(){window.addEventListener('online', () =>{this.isOnline = true;if (this.offlineQueue.length > 0){this.processOfflineQueue()}});window.addEventListener('offline', () =>{this.isOnline = false})}_enableOfflinePersistence(){try{this.db .enablePersistence({synchronizeTabs: true}) .then(() =>{}) .catch((error) =>{if (error.code === 'failed-precondition'){console.warn('⚠️ 여러 탭이 열려있어 오프라인 지속성을 활성화할 수 없습니다.')}else if (error.code === 'unimplemented'){console.warn('⚠️ 브라우저가 오프라인 지속성을 지원하지 않습니다.')}})}catch (error){console.warn('⚠️ 오프라인 지속성 활성화 실패:', error)}}async _retryOperation(operation, maxRetries = PromptManager.MAX_RETRIES, delay = PromptManager.RETRY_DELAY_MS){let lastError;for (let retryIndex = 0;retryIndex < maxRetries;retryIndex++){try{return await operation()}catch (error){lastError = error;if (retryIndex < maxRetries - 1){`);await new Promise((resolve) => setTimeout(resolve, delay));delay *= 2}}}throw lastError}_isNetworkError(error){const networkErrorCodes = ['unavailable', 'deadline-exceeded', 'resource-exhausted', 'cancelled'];return ( networkErrorCodes.includes(error.code) || error.message.includes('network') || error.message.includes('offline') )}_handleFirestoreQueryError(error, operation = '쿼리 실행'){if (error.code === 'permission-denied' || error.code === 'firestore/permission-denied'){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('firestore/permission-denied',{component: 'PromptManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('접근 권한이 없습니다. 로그인 상태를 확인하거나 관리자에게 문의해주세요.')}if (this._isNetworkError(error)){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('network/connection-failed',{component: 'PromptManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('네트워크 연결을 확인해주세요. 오프라인 상태에서는 작업이 자동으로 저장되며, 연결이 복구되면 자동으로 동기화됩니다.')}if (error.code === 'resource-exhausted' || error.message.includes('quota') || error.message.includes('limit')){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('server/service-unavailable',{component: 'PromptManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('쿼리 제한에 도달했습니다. 잠시 후 다시 시도해주세요.')}if (error.code === 'not-found' || error.code === 'firestore/not-found'){if (typeof window !== 'undefined' && window.errorHandler){const errorInfo = window.errorHandler.handle('data/not-found',{component: 'PromptManager', method: operation, originalError: error});throw new Error(`${errorInfo.title}: ${errorInfo.message}${errorInfo.solution}`)}throw new Error('데이터를 찾을 수 없습니다. 페이지를 새로고침하거나 다시 시도해주세요.')}throw error}async getPromptsPaginated(options ={}){try{if (!this.currentUser){throw new Error('로그인이 필요합니다.')}const{limit = 20, startAfter = null, category = null, includeDeleted = false}= options;const cacheKey = startAfter ? null : `promptsPaginated_${JSON.stringify({limit, category, includeDeleted})}`;if (cacheKey && this.cache.has(cacheKey)){const cached = this.cache.get(cacheKey);if (Date.now() - cached.timestamp < this.cacheTimeout){return cached.data}}if (cacheKey && this.pendingRequests.has(cacheKey)){return await this.pendingRequests.get(cacheKey)}const requestPromise = (async () =>{try{let query = this.db .collection(`users/${this.currentUser.uid}/prompts`) .orderBy('createdAt', 'desc') .limit(limit);if (!includeDeleted){query = query.where('isDeleted', '==', false)}if (category){query = query.where('category', '==', category)}if (startAfter){query = query.startAfter(startAfter)}const snapshot = await query.get();const prompts = snapshot.docs.map((doc) => doc.data());const lastDoc = snapshot.docs[snapshot.docs.length - 1];const result ={prompts, lastDoc, hasMore: snapshot.docs.length === limit};if (cacheKey){this.cache.set(cacheKey,{data: result, timestamp: Date.now()})}return result}finally{if (cacheKey){this.pendingRequests.delete(cacheKey)}}})();if (cacheKey){this.pendingRequests.set(cacheKey, requestPromise)}return await requestPromise}catch (error){console.error('❌ 프롬프트 목록 조회 실패:',{error: error.message, stack: error.stack, options: options, userId: this.currentUser?.uid, timestamp: new Date().toISOString()});throw new Error(`프롬프트 목록 조회에 실패했습니다: ${error.message}`)}}_processSnapshotChanges(snapshot){const changes ={added: [], modified: [], removed: []};snapshot.docChanges().forEach((change) =>{const promptData = change.doc.data();if (change.type === 'added'){changes.added.push(promptData)}else if (change.type === 'modified'){changes.modified.push(promptData);this.cache.set(promptData.id,{data: promptData, timestamp: Date.now()})}else if (change.type === 'removed'){changes.removed.push(promptData);this.cache.delete(promptData.id)}});return changes}_logRealtimeSync(changes){const addedCount = changes.added.length;const modifiedCount = changes.modified.length;const removedCount = changes.removed.length}clearCache(){this.cache.clear()}cleanup(){this.stopAllRealtimeSync();this.clearCache();this.optimisticUpdates.clear()}}if (typeof module !== 'undefined' && module.exports){module.exports = PromptManager}