class DiffManager{constructor(options ={}){if (typeof diff_match_patch === 'undefined'){throw new Error('diff-match-patch 라이브러리가 로드되지 않았습니다.')}this.dmp = new diff_match_patch();this.dmp.Diff_Timeout = options.timeout || 1.0;this.dmp.Diff_EditCost = options.editCost || 4;this.cache = new Map();this.maxCacheSize = 50}diff(text1, text2, options ={}){try{this._validateInput(text1, text2);const cacheKey = this._getCacheKey(text1, text2, options);if (this.cache.has(cacheKey)){return this.cache.get(cacheKey)}let diffs;if (options.checkLines){const lineText1 = this.dmp.diff_linesToChars_(text1, text2);diffs = this.dmp.diff_main(lineText1.chars1, lineText1.chars2, false);this.dmp.diff_charsToLines_(diffs, lineText1.lineArray)}else{diffs = this.dmp.diff_main(text1, text2)}if (options.cleanup !== false){this.dmp.diff_cleanupSemantic(diffs)}this._setCache(cacheKey, diffs);return diffs}catch (error){console.error('❌ diff 실패:', error);throw new Error(`텍스트 비교에 실패했습니다: ${error.message}`)}}diffToHtml(diffs, options ={}){try{if (!Array.isArray(diffs)){throw new Error('diffs는 배열이어야 합니다.')}let html = '';let lineNumber = 1;diffs.forEach(([operation, text]) =>{const escapedText = this._escapeHtml(text);let content = escapedText;if (options.showLineNumbers){const lines = escapedText.split('\n');content = lines .map((line) =>{const num = lineNumber++;return `<span class="line-number">${num}</span>${line}`}) .join('\n')}switch (operation){case diff_match_patch.DIFF_INSERT: const insertAttrs = options.addAriaLabels !== false ? ' aria-label="추가됨" role="insertion"' : '';html += `<ins class="diff-insert"${insertAttrs}>${content}</ins>`;break;case diff_match_patch.DIFF_DELETE: const deleteAttrs = options.addAriaLabels !== false ? ' aria-label="삭제됨" role="deletion"' : '';html += `<del class="diff-delete"${deleteAttrs}>${content}</del>`;break;case diff_match_patch.DIFF_EQUAL: html += `<span class="diff-equal">${content}</span>`;break}});return html}catch (error){console.error('❌ HTML 변환 실패:', error);throw new Error(`HTML 변환에 실패했습니다: ${error.message}`)}}diffToPrettyHtml(text1, text2, diffs, options ={}){try{let leftHtml = '';let rightHtml = '';diffs.forEach(([operation, text]) =>{const escapedText = this._escapeHtml(text);switch (operation){case diff_match_patch.DIFF_INSERT: const insertAttrs = options.addAriaLabels !== false ? ' aria-label="추가됨" role="insertion"' : '';rightHtml += `<ins class="diff-insert"${insertAttrs}>${escapedText}</ins>`;break;case diff_match_patch.DIFF_DELETE: const deleteAttrs = options.addAriaLabels !== false ? ' aria-label="삭제됨" role="deletion"' : '';leftHtml += `<del class="diff-delete"${deleteAttrs}>${escapedText}</del>`;break;case diff_match_patch.DIFF_EQUAL: leftHtml += `<span class="diff-equal">${escapedText}</span>`;rightHtml += `<span class="diff-equal">${escapedText}</span>`;break}});return{left: leftHtml, right: rightHtml}}catch (error){console.error('❌ Pretty HTML 변환 실패:', error);throw new Error(`Pretty HTML 변환에 실패했습니다: ${error.message}`)}}getDiffStats(diffs){try{const stats ={insertions: 0, deletions: 0, unchanged: 0, totalChanges: 0, changePercentage: 0};diffs.forEach(([operation, text]) =>{const length = text.length;switch (operation){case diff_match_patch.DIFF_INSERT: stats.insertions += length;stats.totalChanges += length;break;case diff_match_patch.DIFF_DELETE: stats.deletions += length;stats.totalChanges += length;break;case diff_match_patch.DIFF_EQUAL: stats.unchanged += length;break}});const total = stats.insertions + stats.deletions + stats.unchanged;if (total > 0){stats.changePercentage = Math.round((stats.totalChanges / total) * 100)}return stats}catch (error){console.error('❌ 통계 계산 실패:', error);throw new Error(`통계 계산에 실패했습니다: ${error.message}`)}}makePatch(text1, text2){try{this._validateInput(text1, text2);const diffs = this.dmp.diff_main(text1, text2);this.dmp.diff_cleanupSemantic(diffs);const patches = this.dmp.patch_make(text1, diffs);return patches}catch (error){console.error('❌ 패치 생성 실패:', error);throw new Error(`패치 생성에 실패했습니다: ${error.message}`)}}applyPatch(patches, text){try{if (!Array.isArray(patches)){throw new Error('patches는 배열이어야 합니다.')}if (typeof text !== 'string'){throw new Error('text는 문자열이어야 합니다.')}const [resultText, results] = this.dmp.patch_apply(patches, text);const allSuccess = results.every((r) => r === true);=> r).length}/${results.length}성공`);return{text: resultText, success: allSuccess, results: results}}catch (error){console.error('❌ 패치 적용 실패:', error);throw new Error(`패치 적용에 실패했습니다: ${error.message}`)}}calculateSimilarity(text1, text2){try{this._validateInput(text1, text2);const diffs = this.dmp.diff_main(text1, text2);const levenshtein = this.dmp.diff_levenshtein(diffs);const maxLength = Math.max(text1.length, text2.length);if (maxLength === 0) return 100;const similarity = ((maxLength - levenshtein) / maxLength) * 100;return Math.round(similarity * 10) / 10}catch (error){console.error('❌ 유사도 계산 실패:', error);throw new Error(`유사도 계산에 실패했습니다: ${error.message}`)}}_validateInput(text1, text2){if (typeof text1 !== 'string'){throw new Error('text1은 문자열이어야 합니다.')}if (typeof text2 !== 'string'){throw new Error('text2는 문자열이어야 합니다.')}const maxLength = 100000;if (text1.length > maxLength || text2.length > maxLength){console.warn(`⚠️ 대용량 텍스트 감지: ${Math.max(text1.length, text2.length)}자`)}}_escapeHtml(text){const map ={'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'};return text.replace(/[&<>"']/g, (m) => map[m])}_getCacheKey(text1, text2, options){const optionsStr = JSON.stringify(options);return `${text1.length}-${text2.length}-${optionsStr}`}_setCache(key, value){if (this.cache.size >= this.maxCacheSize){const firstKey = this.cache.keys().next().value;this.cache.delete(firstKey)}this.cache.set(key, value)}clearCache(){this.cache.clear()}updateSettings(options ={}){if (options.timeout !== undefined){this.dmp.Diff_Timeout = options.timeout}if (options.editCost !== undefined){this.dmp.Diff_EditCost = options.editCost}}}if (typeof module !== 'undefined' && module.exports){module.exports = DiffManager}