class DualTextWriter {
    constructor() {
        // ë ˆí¼ëŸ°ìŠ¤ ê¸€ ê´€ë ¨ ìš”ì†Œë“¤
        this.refTextInput = document.getElementById('ref-text-input');
        this.refCurrentCount = document.getElementById('ref-current-count');
        this.refMaxCount = document.getElementById('ref-max-count');
        this.refProgressFill = document.getElementById('ref-progress-fill');
        this.refClearBtn = document.getElementById('ref-clear-btn');
        this.refSaveBtn = document.getElementById('ref-save-btn');
        this.refDownloadBtn = document.getElementById('ref-download-btn');
        
        // ìˆ˜ì •/ì‘ì„± ê¸€ ê´€ë ¨ ìš”ì†Œë“¤
        this.editTextInput = document.getElementById('edit-text-input');
        this.editCurrentCount = document.getElementById('edit-current-count');
        this.editMaxCount = document.getElementById('edit-max-count');
        this.editProgressFill = document.getElementById('edit-progress-fill');
        this.editClearBtn = document.getElementById('edit-clear-btn');
        this.editSaveBtn = document.getElementById('edit-save-btn');
        this.editDownloadBtn = document.getElementById('edit-download-btn');
        
        // ê³µí†µ ìš”ì†Œë“¤
        this.savedList = document.getElementById('saved-list');
        this.tempSaveStatus = document.getElementById('temp-save-status');
        this.tempSaveText = document.getElementById('temp-save-text');
        
        this.maxLength = 500;
        this.savedTexts = this.loadSavedTexts();
        this.tempSaveInterval = null;
        this.lastTempSave = null;
        
        this.init();
    }
    
    init() {
        this.bindEvents();
        this.updateCharacterCount('ref');
        this.updateCharacterCount('edit');
        this.renderSavedTexts();
        this.startTempSave();
        this.restoreTempSave();
    }
    
    bindEvents() {
        // ë ˆí¼ëŸ°ìŠ¤ ê¸€ ì´ë²¤íŠ¸
        this.refTextInput.addEventListener('input', () => {
            this.updateCharacterCount('ref');
            this.scheduleTempSave();
        });
        this.refClearBtn.addEventListener('click', () => this.clearText('ref'));
        this.refSaveBtn.addEventListener('click', () => this.saveText('ref'));
        this.refDownloadBtn.addEventListener('click', () => this.downloadAsTxt('ref'));
        
        // ìˆ˜ì •/ì‘ì„± ê¸€ ì´ë²¤íŠ¸
        this.editTextInput.addEventListener('input', () => {
            this.updateCharacterCount('edit');
            this.scheduleTempSave();
        });
        this.editClearBtn.addEventListener('click', () => this.clearText('edit'));
        this.editSaveBtn.addEventListener('click', () => this.saveText('edit'));
        this.editDownloadBtn.addEventListener('click', () => this.downloadAsTxt('edit'));
    }
    
    updateCharacterCount(panel) {
        const textInput = panel === 'ref' ? this.refTextInput : this.editTextInput;
        const currentCount = panel === 'ref' ? this.refCurrentCount : this.editCurrentCount;
        const progressFill = panel === 'ref' ? this.refProgressFill : this.editProgressFill;
        const saveBtn = panel === 'ref' ? this.refSaveBtn : this.editSaveBtn;
        const downloadBtn = panel === 'ref' ? this.refDownloadBtn : this.editDownloadBtn;
        
        const text = textInput.value;
        const currentLength = this.getKoreanCharacterCount(text);
        
        currentCount.textContent = currentLength;
        
        // Update progress bar
        const progress = (currentLength / this.maxLength) * 100;
        progressFill.style.width = `${Math.min(progress, 100)}%`;
        
        // Update character count color based on usage
        if (currentLength >= this.maxLength * 0.9) {
            currentCount.className = 'danger';
        } else if (currentLength >= this.maxLength * 0.7) {
            currentCount.className = 'warning';
        } else {
            currentCount.className = '';
        }
        
        // Update button states
        saveBtn.disabled = currentLength === 0;
        downloadBtn.disabled = currentLength === 0;
    }
    
    getKoreanCharacterCount(text) {
        return text.length;
    }
    
    clearText(panel) {
        const textInput = panel === 'ref' ? this.refTextInput : this.editTextInput;
        const panelName = panel === 'ref' ? 'ë ˆí¼ëŸ°ìŠ¤ ê¸€' : 'ìˆ˜ì •/ì‘ì„± ê¸€';
        
        if (confirm(`${panelName}ì„ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
            textInput.value = '';
            this.updateCharacterCount(panel);
            textInput.focus();
        }
    }
    
    saveText(panel) {
        const textInput = panel === 'ref' ? this.refTextInput : this.editTextInput;
        const text = textInput.value; // trim() ì œê±°í•˜ì—¬ ì‚¬ìš©ì ì…ë ¥ì˜ ê³µë°±ê³¼ ì¤„ë°”ê¿ˆ ë³´ì¡´
        const panelName = panel === 'ref' ? 'ë ˆí¼ëŸ°ìŠ¤ ê¸€' : 'ìˆ˜ì •/ì‘ì„± ê¸€';
        
        if (text.length === 0) {
            alert('ì €ì¥í•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }
        
        const savedItem = {
            id: Date.now() + (panel === 'edit' ? 1 : 0), // í¸ì§‘ ê¸€ì€ IDë¥¼ ë‹¤ë¥´ê²Œ
            content: text,
            date: new Date().toLocaleString('ko-KR'),
            characterCount: this.getKoreanCharacterCount(text),
            type: panel === 'ref' ? 'reference' : 'edit'
        };
        
        this.savedTexts.unshift(savedItem);
        this.saveToLocalStorage();
        this.renderSavedTexts();
        
        this.showMessage(`${panelName}ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!`, 'success');
        
        // Clear input
        textInput.value = '';
        this.updateCharacterCount(panel);
    }
    
    downloadAsTxt(panel) {
        const textInput = panel === 'ref' ? this.refTextInput : this.editTextInput;
        const text = textInput.value; // trim() ì œê±°í•˜ì—¬ ì‚¬ìš©ì ì…ë ¥ì˜ ê³µë°±ê³¼ ì¤„ë°”ê¿ˆ ë³´ì¡´
        const panelName = panel === 'ref' ? 'ë ˆí¼ëŸ°ìŠ¤' : 'ìˆ˜ì •ì‘ì„±';
        
        if (text.length === 0) {
            alert('ë‹¤ìš´ë¡œë“œí•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `${panelName}_${timestamp}.txt`;
        
        const content = `500ì ë¯¸ë§Œ ê¸€ ì‘ì„±ê¸° - ${panelName} ê¸€\n` +
                      `ì‘ì„±ì¼: ${new Date().toLocaleString('ko-KR')}\n` +
                      `ê¸€ì ìˆ˜: ${this.getKoreanCharacterCount(text)}ì\n` +
                      `\n${'='.repeat(30)}\n\n` +
                      `${text}`; // ì‚¬ìš©ìê°€ ì…ë ¥í•œ ê·¸ëŒ€ë¡œ ì¤„ë°”ê¿ˆê³¼ ê³µë°± ìœ ì§€
        
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        this.showMessage(`${panelName} ê¸€ TXT íŒŒì¼ì´ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!`, 'success');
    }
    
    renderSavedTexts() {
        if (this.savedTexts.length === 0) {
            this.savedList.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">ì €ì¥ëœ ê¸€ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
            return;
        }
        
        this.savedList.innerHTML = this.savedTexts.map((item, index) => `
            <div class="saved-item ${index === 0 ? 'new' : ''}">
                <div class="saved-item-header">
                    <span class="saved-item-date">${item.date}</span>
                    <span class="saved-item-count">${item.characterCount}ì</span>
                    <span class="saved-item-type">${item.type === 'reference' ? 'ğŸ“– ë ˆí¼ëŸ°ìŠ¤' : 'âœï¸ ìˆ˜ì •ì‘ì„±'}</span>
                </div>
                <div class="saved-item-content">${this.escapeHtml(item.content)}</div>
                <div class="saved-item-actions">
                    <button class="btn-small btn-edit" onclick="dualTextWriter.editText(${item.id}, '${item.type}')">í¸ì§‘</button>
                    <button class="btn-small btn-delete" onclick="dualTextWriter.deleteText(${item.id})">ì‚­ì œ</button>
                </div>
            </div>
        `).join('');
    }
    
    editText(id, type) {
        const item = this.savedTexts.find(saved => saved.id === id);
        if (item) {
            if (type === 'reference') {
                this.refTextInput.value = item.content;
                this.updateCharacterCount('ref');
                this.refTextInput.focus();
            } else {
                this.editTextInput.value = item.content;
                this.updateCharacterCount('edit');
                this.editTextInput.focus();
            }
            this.refTextInput.scrollIntoView({ behavior: 'smooth' });
        }
    }
    
    deleteText(id) {
        if (confirm('ì´ ê¸€ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            this.savedTexts = this.savedTexts.filter(saved => saved.id !== id);
            this.saveToLocalStorage();
            this.renderSavedTexts();
            this.showMessage('ê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
        }
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    showMessage(message, type = 'info') {
        const messageEl = document.createElement('div');
        messageEl.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : '#17a2b8'};
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            font-weight: 600;
            animation: slideIn 0.3s ease;
        `;
        messageEl.textContent = message;
        
        document.body.appendChild(messageEl);
        
        setTimeout(() => {
            messageEl.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 300);
        }, 2000);
    }
    
    // ì„ì‹œ ì €ì¥ ê¸°ëŠ¥
    startTempSave() {
        this.tempSaveInterval = setInterval(() => {
            this.performTempSave();
        }, 5000);
    }
    
    scheduleTempSave() {
        clearTimeout(this.tempSaveTimeout);
        this.tempSaveTimeout = setTimeout(() => {
            this.performTempSave();
        }, 2000);
    }
    
    performTempSave() {
        const refText = this.refTextInput.value;
        const editText = this.editTextInput.value;
        
        if (refText.length > 0 || editText.length > 0) { // trim() ì œê±°í•˜ì—¬ ì›ë³¸ í¬ë§· ìœ ì§€
            try {
                const tempData = {
                    refText: refText,
                    editText: editText,
                    timestamp: Date.now(),
                    refCharacterCount: this.getKoreanCharacterCount(refText),
                    editCharacterCount: this.getKoreanCharacterCount(editText)
                };
                
                localStorage.setItem('dualTextWriter_tempSave', JSON.stringify(tempData));
                this.lastTempSave = tempData;
                this.showTempSaveStatus();
            } catch (error) {
                console.error('ì„ì‹œ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:', error);
            }
        }
    }
    
    showTempSaveStatus() {
        this.tempSaveStatus.classList.remove('hide');
        this.tempSaveStatus.classList.add('show');
        
        setTimeout(() => {
            this.tempSaveStatus.classList.remove('show');
            this.tempSaveStatus.classList.add('hide');
        }, 3000);
    }
    
    restoreTempSave() {
        try {
            const tempData = localStorage.getItem('dualTextWriter_tempSave');
            if (tempData) {
                const data = JSON.parse(tempData);
                
                const now = Date.now();
                const dayInMs = 24 * 60 * 60 * 1000;
                
                if (now - data.timestamp < dayInMs) {
                    if (confirm('ì„ì‹œ ì €ì¥ëœ ê¸€ì´ ìˆìŠµë‹ˆë‹¤. ë³µì›í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                        if (data.refText) {
                            this.refTextInput.value = data.refText;
                            this.updateCharacterCount('ref');
                        }
                        if (data.editText) {
                            this.editTextInput.value = data.editText;
                            this.updateCharacterCount('edit');
                        }
                        this.showMessage('ì„ì‹œ ì €ì¥ëœ ê¸€ì´ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                    }
                } else {
                    localStorage.removeItem('dualTextWriter_tempSave');
                }
            }
        } catch (error) {
            console.error('ì„ì‹œ ì €ì¥ ë³µì›ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:', error);
        }
    }
    
    loadSavedTexts() {
        try {
            const saved = localStorage.getItem('dualTextWriter_savedTexts');
            return saved ? JSON.parse(saved) : [];
        } catch (error) {
            console.error('ì €ì¥ëœ ê¸€ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:', error);
            return [];
        }
    }
    
    saveToLocalStorage() {
        try {
            localStorage.setItem('dualTextWriter_savedTexts', JSON.stringify(this.savedTexts));
        } catch (error) {
            console.error('ê¸€ì„ ì €ì¥í•˜ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:', error);
            this.showMessage('ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
        }
    }
    
    cleanupTempSave() {
        if (this.tempSaveInterval) {
            clearInterval(this.tempSaveInterval);
        }
        if (this.tempSaveTimeout) {
            clearTimeout(this.tempSaveTimeout);
        }
    }
}

// Initialize the application
let dualTextWriter;

document.addEventListener('DOMContentLoaded', () => {
    dualTextWriter = new DualTextWriter();
});

// í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ì •ë¦¬ ì‘ì—…
window.addEventListener('beforeunload', () => {
    if (dualTextWriter) {
        dualTextWriter.cleanupTempSave();
    }
});

// Add CSS for message animations
const style = document.createElement('style');
style.textContent = `
    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateX(100%);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
    
    @keyframes slideOut {
        from {
            opacity: 1;
            transform: translateX(0);
        }
        to {
            opacity: 0;
            transform: translateX(100%);
        }
    }
`;
document.head.appendChild(style);